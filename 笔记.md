1.InnoDB存储引擎
### 调用顺序在AbstractAutowireCapableBeanFactory.initializeBean()方法中实现:


`setAware`
->
`InstantiationAwareBeanPostProcessor`.postProcessBeforeInstantiation(实例化之前)
->
`实例化`
->
`InstantiationAwareBeanPostProcessor`.postProcessAfterInstantiation
->
`InstantiationAwareBeanPostProcessor`.postProcessPropertyValues(设置属性之前)
->
`BeanPostProcessor`.postProcessBeforeInitialization(可对bean进行二次加工)
-> 
`InitializingBean`.afterPropertiesSet 
-> 
`bean`.init-method 
-> 
`BeanPostProcessor`.postProcessAfterInitialization
->
`bean为prototype`返回给调用者(由调用者维护声明周期),singleton放入缓存池,引用返回给调用者
->
->
bean.destroy_method(singleton才会触发)
  
> `InitDestroyAnnotationBeanPostProcessor` 负责针对JSR250中 PostConstruct,PreDestroy注解进行处理
> `AspectjWeavingEnabler`,`CustomAutowireConfigurer`,`ConfigurationClassPostProcessor`这些为工厂的后处理器,为容器级别的在应用上下文装配配置文件后立即调用

### FactoryBean接口
   * 实现该接口可以直接通过new方式获取bean,类似@Bean,通过getObject()方法返回



###Spring redis缓存集成
* xml与javaConfig会注册`CacheInterceptor`,该方法实现`MethodInterceptor`,注意该方法拦截所有方法,但是要不要对方法进行增强则是由`CacheOperationSourcePointcut`来决定,该方法实现[StaticMethodMatcherPointcut](#jumps)接口,需要增强方法的匹配由`AnnotationCacheOperationSource`扫描相关缓存注解来决定, 上述相关定义在`ProxyCachingConfiguration`中,
* 同时spring支持JSR-107规范,额外会注册JCacheInterceptor,前提项目中引入了java缓存包
* 

###java安装:
> vim /etc/profile  
> JAVA_HOME=/usr/local/java  
> PATH=$JAVA_HOME/bin:$PATH  
> CLASSPATH=$JAVA_HOME/jre/lib/ext.jar:$JAVA_HOME/lib/tools.jar  
> export PATH JAVA_HOME CLASSPATH  

> * window拷贝到centos中文件格式转换
> * :set ff? 查看文件内容格式
> * :set ff=unix 强制转换

### Google Guava

### Spring Boot
* `@ConditionalOnBean`：当前容器有指定Bean的条件下。
* `@ConditionalOnClass`：当前类路径下有指定的类的条件下。
* `@ConditionalOnExpression`：基于SpEL表达式作为判断条件。
* `@ConditionalOnJava`：基于JVM版本作为判断条件。
* `@ConditionalOnJndi`：在JNDI存在的条件下查找指定的位置。
* `@ConditionalOnMissingBean`：当容器里没有指定Bean的情况下。
* `@ConditionalOnMissingClass`：当类路径下没有指定的类的条件下。
* `@ConditionalOnNotWebApplication`：当前项目不是WEB项目的条件下。
* `@ConditionalOnProperty`：指定属性是否有指定的值。
* `@ConditionalOnResource`：类路径是否有指定的值。
* `@ConditionalOnSingleCandidate`：当指定Bean在容器中只有一个，或者虽然有多个但 是指定首选的Bean。
* `@ConditionalOnWebApplication`：当前项目是WEB项目的条件下。

### Spring Boot初始化的listener如下:
* `ConfigServerBootstrapApplicationListener`- min+4
* `FileEncodingApplicationListener`- max
* `AnsiOutputApplicationListener`- min+11
* `ConfigFileApplicationListener`- min+10
* `DelegatingApplicationListener`- 0
* `ClasspathLoggingApplicationListener`- min+21
* `LoggingApplicationListener`- min+20
* `BackgroundPreinitializer`- min+21
* `BootstrapApplicationListener`- min+5
* `LoggingSystemShutdownListener`- min+6
### 过滤一下部分
* `ClearCachesApplicationListener`
* `ParentContextCloserApplicationListener`
* `LiquibaseServiceLocatorApplicationListener`
* `RestartListener`

### Spring Boot初始化的initializer如下:
* `ConfigurationWarningsApplicationContextInitializer`
* `ContextIdApplicationContextInitializer`
* `DelegatingApplicationContextInitializer`
* `ServerPortInfoApplicationContextInitializer`
* `SharedMetadataReaderFactoryContextInitializer`
* `AutoConfigurationReportLoggingInitializer`



### Spring Boot Actuator说明:
![](https://i.imgur.com/0GQwfRW.png)

## spring启动基本说明:

* `ConfigurationClassPostProcessor`负责全局解析注解
* `ConfigurationClassParser`在上述类中负责真实解析,分类返回类定义结果
* 在`ConfigurationClassPostProcessor`注册bean

* `ImportBeanDefinitionRegistrar` 在实例化响应自定义注解时,会调用在该注解上@Import指定的实现`ImportBeanDefinitionRegistrar`接口的类,可以在`registerBeanDefinitions`方法中获取响应注解的参数信息
* `ImportSelector` 在实例化Configuration配置信息时,是否需要额外导入其他类,通过返回值数组来决定是否需要导入





### JVM 三特性
* 原子性
* 可见性
* 有序性

**红黑树:**

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

![](https://i.imgur.com/r3kP1c9.png)

### 位与运算 [原文件地址](https://github.com/wangyanbing/carry/blob/master/src/main/java/com/beetl/bit/BitWeiYunSuan.java)
![](https://i.imgur.com/Mp6U1xi.png)

##Quartz
####相关类名说明
* **Job**: 是一个接口,只有一个方法execute(JobExecutionContext context) 开发者可以通过实现该接口来定义要执行的任务,JobExecutionContext 提供了调度上下文的各种信息,Job运行时的信息保存在JobDataMap中
* **JobDetail**: Quartz在每次执行Job时,都重新创建一个Job实例,所以他不是直接接收一个Job实例,而是接收一个实现类,以便于运行时通过newInstance()的反射调用机制实例化Job,因此需要通过一个类来描述Job的实现类及相关的静态信息,如Job名称,描述,关联监听器等信息,JobDetail承担这一个角色
* **Trigger**:描述触发Job执行的时间触发规则,主要有两个实现类SimpleTrigger和CronTrigger两个子类,触发一次或固定周期间隔执行使用SimpleTrigger
* **Calendar**:他是日历特定时间点的集合(可以简单认为是java.util.Canlendar集合),一个Trigger可以与多个Calendar关联,以便排除或者包含某些时间点,假设每周一早上10:00执行任务,如果遇到法定节假日则不执行,这就需要在Trigger基础上使用Calendar进行定点排除,实现类AnnualCalendar,MonthlyCalendar,WeeklyCalendar,分别针对每年,每月,每周进行定义
* **Scheduler**:代表一个Quartz的独立运行容器,Trigger,JobDetail可以注册进去,二者在Scheduler中拥有各自的组和名称,组和名称是Scheduler查找定位容器中某一个对象的依据,Trigger,JobDatail的组和名称的组合必须唯一.Scheduler定义了多个接口方法,运行外部通过组及名称访问和控制容器中的Trigger,JobDetail.Scheduler可以将Trigger绑定到某一JobDetail中,当Trigger触发时,就会执行毒地应的Job,一个Job可以对应多个Trigger,一个Trigger只能对应一个Job.可以通过SchedulerFactory创建一个Scheduler实例,Scheduler拥有一个SchedulerContext,保存着上下文信息,Job和Trigger都可以访问SchedulerContext中的信息,他内部采用Map,通过键值对维护这些上下文信息
* **ThreadPool** Schedulers使用一个线程池为任务运行的基础设施,任务通过共享线程池中的线程来提高运行效率
####详细说明
* Job拥有一个StatefulJob子接口,表示有状态的任务,无方法.仅仅为让Quartz知道任务的类型
* 无状态任务在执行时,拥有自己的JobDataMap复制,对JobDataMap进行更改不会影响下次的执行,而有状态的共享一个JobDataMap实例,修改后会影响下次执行.因此无状态可以并发操作,有状态无法并发操作
* Trigger自身也拥有一个JobDataMap,可以通过JobExecutionContext#getTrigger().getJobDataMap().不管有状态还是无状态,对JobDataMap进行更改都不会影响下次操作

![](https://i.imgur.com/sXXTx6w.png)

* TriggerUtils工具类提供一些获取特定时间的方法,还拥有多个常见的Trigger的方法

#### quartz表达式说明

![](https://i.imgur.com/MOUISVd.png)
----------
## java NIO

Buffer 属性说明:
 
* > capacity:容量,buffer最多存放的元素数量;
* > limit:可以使用的上限,创建时该值与capacity值一样,例如初始容量为100,现在往里面写入20个元素数据后,再读取limit 变为20;
* > position:当前所操作元素所在的索引位置 position从0开始,随着get,put方法自动更新
* > mark:用来暂时保存position的值,例如如果当前position位置为10,需要读取position为15的值,这个时候mark一下,而后设置position值为15读取即可,再调用reset后position值即恢复为10
> mark <= position <= limit <= capacity

* > clear:初始化limit,position,mark,让limit = position position=0 mark = -1
* > flip:保存数据时 保存一个数据postion+1,保存完后如果想读取出来就需要将最好postion位置让给limit,然后将position位置设置为0这个就可以读取所有保存的数据了


### Tomcat启动时序图
![](https://i.imgur.com/P2ySS27.png)

###Spring源码解析
* **AliasRegistry** 定义了对alias的增删改查方法
* **SimpleAliasRegistry** 使用Map对alias进行缓存并对AliasRegistry进行了实现
* **SingletonBeanRegistry** 定义对单例的注册和获取
* **BeanFactory** 定义获取bean及bean属性的方法
* **DefaultSingletonBeanRegistry** 对SingletonBeanRegistry接口进行了实现
* **HierarchicalBeanFactory** 继承BeanFactory,增加对父Factory的支持
* **BeanDefinitionRegistry** 继承AliasRegistry,额外定义了对BeanDefinition的增删改查方法
* **FactoryBeanRegistrySupport** 继承DefaultSingletonBeanRegistry,增加了对FactoryBean的支持
* **ConfigurableBeanFactory** 提供了对BeanFactory配置的方法
* **ListableBeanFactory** 根据各种条件获取bean的配置信息
* **AbstractBeanFactory** 综合FactoryBeanRegistrySupport与ConfigurableBeanFactory的功能
* **AutowireCapableBeanFactory** 提供了创建Bean,自动注入,初始化以及应用bean的后处理器
* **AbstractAutowireCapableBeanFactory** 综合AbstractBeanFactory并对接口AutowireCapableBeanFactory进行了实现
* **ConfigurableListableBeanFactory** BeanFactory配置清单,指定忽略类型及接口
* **DefaultListableBeanFactory** 综合上面所有功能,主要对bean注册后的处理
* **XmlBeanFactory** 继承DefaultListableBeanFactory,主要从xml读取BeanDefinition,增加了XmlBeanDefinitionReader类型的reader属性,使用reader属性对资源文件进行读取和注册
* **BeanDefinitionReader** 定义资源文件读取并转换为BeanDefinition的各种功能

### Spring Mvc源码解析
##### DispactcherServlet说明:

* **XXXAware** 在spring中表示对XXX可以感知,通俗解释:如果某个类想使用spring的一些东西就可以通过XXXAware告诉spring,spring在看到后会送给你,而接收的方式是通过实现接口的唯一方法set-XXX.例如一个类想使用当前的ApplicationContext我们只需要让他实现ApplicationContextAware接口然后实现唯一的方法void setApplicationContext(ApplicationContext context)就可以了,spring会自动调用这个方法将ApplicationContext传递给我们,我们只需要接收即可
* **EnvironmentCapable** 具有Environment的能力,也就说可以提供Environment,所以他的唯一方法是Environment getEnvironment(),用于实现EnvironmentCapable接口的类,告诉spring它可以提供Environment,当spring需要用Environment的时候,spring就会调用getEnvironment跟他要
* **BeanWrapper**: 它可以直接修改一个类的属性

* **HandlerExceptionResolver** 异常处理器解析器,detectAllHandlerExceptionResolvers来确认是通过类型加载HandlerExceptionResolver(所有的)还是通过handlerExceptionResolver名称+类型来加载(指定名称类型的),如果没有定义默认会注册在dispatcherServlet.properties文件中定义的以下三个:AnnotationMethodHandlerExceptionResolver(3.2后过时),ResponseStatusExceptionResolver,DefaultHandlerExceptionResolver
* **RequestToViewNameTranslator** 如果处理器返回的view为空时,从request中获取viewName,默认实现在dispatcherServlet.properties中配置的DefaultRequestToViewNameTranslator
* **MethodIntrospector#selectInvocableMethod** 根据给定方法查找对应类上是否存在该方法,如果方法所在类与目标类一样则直接返回该方法,否则查询父类方法如果找到则返回如果找不到在目标类中查找,如果查找不到则跑异常
* **RequestMappingHandlerAdapter** 请求处理器适配器. 1 参数绑定 2 调用methodHandler 3 返回组装modelView 
* **ModelAndViewResolver** 自定义视图解析器,实现该接口后需要注入到RequestMappingHandlerAdapter里面,默认的supportsReturnType返回true,但在HandlerMethodReturnValueHandler中排在最后,即当其他返回值处理器无法匹配时才执行该项
* **HandlerMethodArgumentResolver** 参数解析器,一般实现类XXXMethodArgumentResolver 或者XXXMethodProcessor 前者是参数解析器 后者除了解析参数还可以处理对应类型的返回值数据,即同时实现了[HandlerMethodReturnValueHandle](#handlerMethodReturnValueHandle) XXX表示要解析的参数类型.最后还有XXXAdapter 主要是兼容WebArgumentResolver,用来处理自定义的解析方法
* <span id="handlerMethodReturnValueHandle">**HandlerMethodReturnValueHandle**</span>返回值类型处理器
* **AbstractNamedValueMethodArgumentResolver**  解析namedvalue类型参数(name参数如:cookie,requestParam,requestHeader,pathVariable等)的基类,主要功能:获取name,resolverDefaultValue,handleMissingValue,handleNullValue,调用模板方法resolveName,handleResolvedValue具体解析

* Servlet3.0容器启动时会在类路径下查找实现了**ServletContainerInitializer**接口的类,而spring刚好实现了上述接口SpringServletContainerInitializer,同时@HandlesTypes可以指定类或接口(默认是WebApplicationInitializer),这样容器就会查找实现该接口的类,并将结果传入到onStartup方法中,因此SpringServletContainerInitializer在onStartup中获取到结果后触发WebApplicationInitializer的onStartup方法.另外spring提供了一个抽象类AbstractAnnotationConfigDispatcherServletInitializer实现WebApplicationInitializer接口,使得他在注册DispatcherServlet时只需要简单指定他的Servlet映射即可,当应用部署到3.0容器时,容器启动时会自动发现他并配置Servlet上下文
* **AsyncRestTemplate** 使用SimpleClientHttpRequestFactory进行Http操作,底层采用java.http.HttpURLConnection实现
####注解说明
 
>  * `@ModelAttribute`注解可以将入参放入模型对象以便于渲染数据.ModelAttribute在方法时,会在执行处理前执行,将设置的value值作为key,返回值设置到model里面
>  *  Map,ModelMap,Model:如果入参定义这些参数,在处理方法返回时就会将这些参数加入到模型中,同**@ModelAttributey**一样
>  * `@SessionAttribute`注解可以将某个属性暂存HttpSession中以便于在回话中反复使用
>  * `@MatrixVariable` 
>  * `@RequestBoby` 从request中的body中读取application/json application/text等对象同时绑定到响应的对象中
>  * `@Lazy` 在调用此属性的时候才会注入属性值,和autowired同时出现,且要注入的bean声明为@Lazy
![](https://i.imgur.com/PTLpfEo.png)

* Formatter接口提供了对数据本身进行格式化操作,该接口继承Printer<T>(对象的格式化输出),Parser<T>(对象的格式化输入),实现类:
  * NumberFormatter:用于数字类型对象的格式化
  * CurrencyFormatter:用于货币类型对象的格式化
  * PercentFormatter:用于百分数数字类型对象的格式化
* 基于注解驱动的格式化接口 AnnotationFormatterFactory<T extends Annotation>,spring内置了两个实现类
  * NumberFormatAnnotationFormatterFactory @NumberFormatter
  * JodaDateTimeFormatAnnotationFormatterFactory @DateTimeFormat
* LocalValidatorFactoryBean实现了Spring的Validator接口,又实现了JSR-303的Validator接口,但Spring本身并没有提供JSR-303的实现,需要将Hibernate-Validator放在相应的类路径下才可以

### MAVEN
filter说明:

* filter会在打包编译的时候将properites,xml文件中${} 替换为profile配置的properties的信息,注意 需要开启<filtering>true</filtering>

#### JAVA
###### 反射:
* parameter.isNamePresent 用来确定编译时是否包含参数信息,如果不包含则在.getName()时,参数会以arg0,arg1等依次排列显示

###### Bridge method 桥方法:
* 在定义泛型的接口方法里,由于方法没有指定参数类型,因此在调用的时候可以是任意类型,但实际调用时却是实现方法所指定的参数类型,这个时候就会出现调用错误的问题,因此虚拟机在编译的时候会对接口的泛型的方法创建两个方法,除了实现接口方法指定的参数外,还会创建一个Object类型作为参数的方法(注意实现的方法需要为public),而这个额外生成的方法会强制将参数转换为对应的类型,最终会调用真实实现的接口方法.所以在指定泛型的类里面如果泛型参数类型传递错误,在强制转换的时候会异常

###### 四舍五入
* **ROUND_UP**：远离零方向舍入，即向绝对值最大的方向舍入，只要舍弃位非0即进位。
* **ROUND_DOWN**：趋向零方向舍入，即向零方向靠拢，注意所有的位都舍弃，不存在进位情况。
* **ROUND_CEILING**：向正无穷方向舍入，若为正数，舍入行为类似ROUND_UP；若为负数，则类似ROUND_DOWN。注意：* Math.round()方法即为此模式。
* **ROUND_FLOOR**：向负无穷方向舍入，若为正数，舍入行为类似ROUND_DOWN；若为负数，则类似ROUND_UP。
* **HALF_UP**：最近数字舍入(5进)，这是最经典的四舍五入模式。
* **HALF_DOWN**：最近数字舍入(5舍)，在四舍五入中，5是进位的，而在HALF_DOWN中是舍弃不进位的。
* **HALF_EVEN**：银行家算法，主要运用于商业运算的项目中，以确保相关数据计算的准确性。


###类加载器
* 针对同一个类进行加载,如果选择的加载器不一样,产生的对象也会不一样 instanceof 结果为false

######1.8日期工具类
* ChronoUnit:类可用于在单个时间单位内测量一段时间，例如天数或秒。
* Duration
* Period



## java基础
String.lastIndexOf(str,fromIndex); 指在字符串0~fromIndex(包含)之间最后一次出现str的索引位置
######线程
* 线程的5个状态,在任意一个时间点,一个线程只能有且只有一种状态:
* **新建(New)** 创建后尚未启动的线程处于这种状态
* **运行(Runable)** Runable包括了操作系统状态中的Running与Ready,也就是说处于此状态的线程可能正在执行,也可能在等待CPU为它分配执行时间
* **无限期等待(Waiting)** 处于这种状态的线程不会被分配CPU执行时间,他们要等待被其他线程显式唤醒.以下几种会让线程无限期等待:
	* 没有设置Timeout参数的Object.wait()方法
	* 没有设置Timeout参数的Object.join()方法
	* LockSupport.park()方法
* **限期等待(Timed Waiting)** 处于该状态的线程也不会被分配CPU执行时间,不过无效等待其他线程显式唤醒,在一定时间后他们将有系统自动唤醒,以下几种会让线程限期等待:
	* Thread.sleep()
	* 设置了timeout参数的Object.wait()方法
	* 设置了timeout参数的Object.join()方法
	* LockSupport.parkNanos()方法
	* LockSupport.parkUntil()方法
* **阻塞(Blocked)** 线程被阻塞了,"阻塞状态"与"等待状态"的区别是,阻塞状态在等待着获取到一个排他锁,这个事件将在另一个线程放弃这个锁的时候发生,而等待状态则是等待一段时间或者唤醒动作的发生.在程序等待进入同步区域的时候,线程将进入这种状态
* **结束(Terminated)** 已终止线程的线程状态,线程已经结束执行
* BigDecimal.compareTo(BigDecimal) 如果第一个大于第二个返回 1 第一个等于第二个返回 0 第一个小于第二个返回 -1

#### 泛型
* public <T extends List,V extends List,R extends List> String say(T abc, V v,R r) 返回值前面的泛型强制确定入参的值的类型

### java规范
* 规范要求lock,unlock,read,load,assign,use,store,write 8个操作为原子性

## 深入迁出JAVA内存



## 设计模式之禅


##实战Java高并发程序设计

* **饥饿** 线程优先级可能太低,导致无法获取资源.还有可能是另一个线程长时间占用资源导致其他需要该资源的线程无法执行
* **活锁** 两个线程主动释放资源给他人使用,导致资源不断在两个线程之间跳动,而没有线程可拿到资源执行
* **scheduleAtFixedRate** 线程池周期性执行某个任务,开始于指定的延迟时间后,以给定的周期,循环执行
* **scheduleWithFixedDelay** 线程池周期性执行某个任务开始于指定的延迟时间后,以给定的周期,在上个任务结束+周期时间循环执行
### CAS 
* **AtomicReference** 封装了对象级别的CAS操作 AtomicInteger则是Integer级别的.针对cas操作时,如果对象在执行cas之前已经改变且又变回来,则无法被感知到,即cas操作无法正确的判断当前数据的状态
* **AtomicStampedReference** 与上述不同,该类带有时间戳状态,即在更新对象值的时候同时也必须更新时间戳
* **AtomicIntegerArray** **AtomicLongArray** **AtomicReferenceArray** 可用的原子数组
* **Unsafe.arrayBaseOffset()** 获取数组第一个元素的偏移量
* **Unsafe.arrayIndexScale()** 获取数组中一个元素的大小
* 数组明面上的大小将会是 偏移量+每个数组的大小*数组的长度(offset + scale * Array.length)
### CLH锁


##Spring基础 JAVA EE开发的颠覆者


* **DI** 依赖注入,容器负责创建对象和维护对象之间的依赖关系
* **@Value**说明:
  * @Value("ergehenmeng") 字符串注入
  * @Value("#{systemProperties['os.name']}") 系统属性注入
  * @Value("#{T(java.lang.Math).random() * 100 }") 运算方法注入
  * @Value("#{demoService.another}") 其他bean属性注入 demoService是其他的一个bean another为其属性
  * @Value("classpath:com/fanyin/text.txt") 文件注入
  * private Resource text;
  * @Value("${book.name}")配置文件属性注入
* **@PostConstruct** 构造方法执行完之后执行 JSR250 与Bean(init="xxxMethod")一样
* **@PreDestroy** 在Bean销毁之前执行 JSR250 与Bean(destroy="xxxMethod")一样
* **@Profile** 注解类或方法,在不同的情况下初始化不同的bean.在servlet2.5及之前需要在web.xml中配置,之后配置如下:
![](https://i.imgur.com/qxDvdmL.png)
* **spring事件** 为bean与bean之间消息通讯提供了支持,当一个bean处理完一个任务之后,希望另一个bean做响应的处理,则需要另一个bean监听当前bean发出事件
  * 自定义事件 实现ApplicationEvent接口;
  * 定义事件监听器 实现ApplicationListener;
  * 使用容器发布事件ApplicationContext.publishEvent
* **Spring Aware** 使普通bean感知容器存在,使用这些接口,bean将会和spring框架耦合
  * BeanNameAware 获取容器中bean的名称
  * BeanFactoryAware 获取当前beanFactory
  * ApplicationContextAware* 获取当前application context
  * MessageSourceAware 获取message source,可以获取文本信息
  * ApplicationEventPublishAware 应用事件发布器,可以发布事件
  * ResourceLoaderAware 获取资源加载器,可以加载外部资源文件
* **TaskExecutor** 基于线程池的"任务执行器" 实现AsyncConfigurer的getAsyncExecutor方法来定义TaskExecutor
* **计划任务** 
  * 3.1之后只需要开启@EnableScheduling即可,在需要执行计划任务的方法上注解@Scheduled,声明这是一个计划任务
* **@Conditional** 
  * spring4.0提供了更高级的基于条件的创建Bean的方法
* **@ImportResource** 加载xml配置文件
* **@Import** 加载单个类配置,或者普通bean或者ImportSelector等
* **@ConfigurationProperties** 基于类型安全的配置方式 
* **@PropertySources** 加载多个properties文件,java 1.8支持同一个注解在一个类上重复定义的,因此可以使用@PropertySource加载多个properties
* **spring.profiles.active** 用来配置生产环境,开发环境等,命名方式: application-*(dev,pro).properties
* 将静态文件index.html放置到如下目录,当访问项目根目录时会直接映射(前提不进行额外的拦截操作).同时网站logo放在以下目录会直接生效
  * classpath:/META-INF/resources/index.html
  * classpath:/resources/index.html
  * classpath:/static/index.html
  * classpath:/public/index.html
* **@SpringApplicationConfiguration** 单元测试注解 指定application启动类
* **spring-actuator** 监控模块 
  * ip:port/actuator
  * ip:port/autoconfig
  * ip:port/beans
  * ip:port/dump
  * ip:port/configprops
  * ip:port/health
  * ip:port/info
  * ip:port/metrics
  * ip:port/mappings
  * ip:port/shutdown 默认是关闭的 endpoints.shutdown.enabled=true开启 支持post请求  management.port=8081指定端口
  * ip:port/trace
  * endpoints.beans.id=
  * 
  * mybean 针对上述可指定访问的地址
* `@AutoConfigureBefore` 在某个配置之前执行 一般在@Configuration上使用
* `@AutoConfigureAfter` 在某个配置完成之后执行 一般在@Configuration上使用

##精通Spring+4.x企业应用开发实战
* **spring Resource**接口支持的地址前缀
  * classpath: 类路径加载 classpath:与classpath:/同价
  * file: 从文件系统装载资源,可以是相对路径也可以是绝对路径
  * http:// 从web服务器加载资源
  * ftp://从ftp服务器加载资源
  * 没有前缀: 根据ApplicationContext的具体实现类采用对应类型的Resource
  * classpath*: 针对多jar或者文件系统拥有相同的包名,classpath:只会在第一个加载的包路径下进行查找,而classpath*:则会扫描所有的包路径
* Ant风格的资源地址通配符
  * ? 匹配文件名中的一个字符
  * * 匹配文件名中的任意字符
  * ** 匹配多层路径
* **ContextLoaderListener** spring方法 实现了ServletContextListener用来监听ServletContext初始化和销毁
* **RequestContextListener** spring方法 实现了ServletRequestListener用来监听ServletRequest请求初始化和销毁
* **RequestHandlerEvent** 与web应用相关的事件,当一个Http请求被处理后,产生该事件,只有定义了DispatchServlet时才产生改事件,它有两个子类分别代表Servlet与Portet的请求事件
* **ApplicationContextEvent** 容器时间,有四个子类,分别是启动,刷新,停止,关闭的事件

##AOP概论
* **连接点(JoinPoint)** 程序执行的某个特定位置,通俗讲就是要使用aop要增强的方法的什么地方(之前,之后,异常等)
* **切点(Pointcut)** 相当于要作用方法的条件,即对哪些方法进行增强
* **增强(Advice)** 要增加的aop业务代码,即在目标类上增加的代码
* **目标对象(Target)** 要增强的目标类
* **引介(Introduction)** 是一种特殊的增强,它为类添加一些属性和方法,这样即使一个业务类原本没有实现某个接口,通过Aop的引介功能,也可以动态为该业务类添加接口的实现逻辑,让业务类成为这个接口的实现类
* **织入(Weaving)** 将增强添加到目标类的具体连接点的过程
* **代理(Proxy)** 一个类被aop织入增强后,就产生了一个结果类,他是融合了原类和增强逻辑的类,根据不通的代理方式,代理类可能是和原类具有相同接口的类,也可能就是原类的子类,也就是说可以采用与调用原类相同的方式调用代理类
* **切面(Aspect)** 切面由切点与增强(引介)组成,他即包含横切逻辑的定义,也包含连接点的定义.
####AOP织入方式
* 编译期织入,这要求特殊的java编译器
* 类装载期织入,这要求特殊的类装载器
* 动态代理织入,在运行期为目标类添加.增强.生成子类的方法
* Spring采用动态代理模式织入,而AspectJ采用编译期织入和类装载期织入
####ProxyFacotryBean
* **target** 代理的目标对象
* **proxyInterfaces** 代理所实现的接口,可以为多个
* **InterfacesNames** 需要织入目标对象的Bean列表,这些类必须实现MethodInterceptor或者Advisor的Bean,支持排序
* **singleton** 返回的代理对象是否为单例,默认是单例
* **optimize** 当设置为true时,强制使用CGLib动态代理,cglib创建对象速度慢(适合单例),运行效率高,jdk代理创建对象速度快,运行效率慢
* **proxyTargetClass** 是否对类进行代理(而不是对接口进行代理),设置为true则使用CGLib代理,设置该属性后会忽略proxyInterfaces属性
####增强类型
* **MethodBeforeAdvice** 前置增强
* **AfterReturnAdvice** 后置增强,如果异常是方法内部声明的异常,则该异常归目标方法中,如果不是,则Spring将其转换为运行期异常抛出
* **MethodInterceptor** 环绕增强,采用AOP联盟定义实现接口
* **ThrowsAdvice** 异常抛出增强,空接口,在运行期Spring使用反射机制自行判断,必须采用以下签名形式定义异常抛出的增强方法
  * void afterThrowing([Method method,Object[] args,Object target],Throwable)
  * 注意前三个方法要么同时提供,要么同时不提供
  * 如果定义两个异常方法,异常类型不一样,Spring会优先选择相似度高的调用
* **IntroductionInterceptor** 引介增强,属于一种特殊的增强方式,他不是在目标类方法周围织入增强,而是为目标类创建新的方法和属性,所以引介增强是类级别的,通过引介增强,可以为目标类增加一个接口的实现,即原来的目标类未实现某个接口,通过引介增强为目标类创建实现某个接口的代理,Spring默认实现类型DelegatingIntroductionInterceptor,一般情况下都是扩展该类实现自己的增强类
####创建切面
* Spring通过PointCut接口来描述切点,该接口由ClassFilter与MethodMatcher,一个是定位特定类上,一个定位特定方法上
* Spring支持两种方法匹配器:静态方法匹配器和动态方法匹配器,静态匹配仅对方法签名(方法名和入参类型及顺序)进行匹配,动态匹配是在运行期检查方法的入参,每次调用方法可能入参都不一样所以每次都会判断,因此对性能有影响
####切点类型
`静态方法切点` <span id="jumps">StaticMethodMatcherPointCut是静态方法切点的抽象基类,默认情况下他匹配所有的类,他包含两个子类NameMatchMethodPointCut和AbstractRegexpMethodPointcut前者提供简单的字符串匹配方法签名,后者使用正则表达式匹配方法签名</span>
`动态方法切点` DynamicMethodMatcherPointcut是动态方法切点的基类,默认情况下他匹配所有的类
`注解切点` AnnotationMatchingPointcut实现类表示注解切点 使用AnnotationMatchingPointcut支持在bean中直接通过注解标签定义的切点
`表达式切点`ExpressionPointcut为了支持AspectJ切点表达式语法定义的接口
`流程切点` ControlFlowPointcut是一种特殊的切点,他根据程序执行堆栈的信息查看目标方法是否有某一个方法直接或间接发起调用,以此来判断是否为匹配的连接点
`复合切点` ComposablePointcut 为创建多个切点而提供的方便操作类,他所有的方法都返回ComposablePointcut类,这样就可以使用链表表达式对切点进行操作
####切面类型
* **Advisor** 代表一般的切面 仅包含一个Advice,因为Advice包含横切代码和连接点的信息,所有Advice本身就是一个简单的切面
* **PointcutAdvisor** 代表具有切点的切面,包含Advice和Pointcut两个类,这样就可以通过类,方法名,方法方位等信息灵活的确认切面的连接点,六个实现类:
  * **DefaultPointcutAdvisor**: 最常用的切面类型,他可以通过任意Pointcut和Advice定义一个切面,不支持引介的切面类型,一般通过扩展该类实现自定义的切面
  * **NameMatchMethodPointcutAdvisor**: 通过该类可以定义按方法名定义切点的切面
  * **RegexpMethodPointcutAdvisor**: 正则表达式匹配方法进行切点定义的切面,可以通过扩展该类实现类进行操作,内部通过JdkRegexpMethodPointcut
  * **StaticMethodMatcherPointcutAdvisor**: 静态方法匹配器切点定义的切面 默认情况下匹配所有的目标类
  * **AspectJExpressionPointcutAdvisor**: 用于AspectJ切点表达式定义切点的切面
  * **AspectJPointcutAdvisor**: 用于AspectJ语法定义切点的切面
* **IntroductionAdvisor** 引介切面,他是对应引介增强的特殊的切面,他应用于类层面上,所以引介切点使用ClassFilter定义
  * 有两个实现类,DefaultIntroductionAdvisor和DeclareParentsAdvisor,前者是引介切面最常用的实现类,后者用于实现AspectJ语言的DeclareParent注解表示的引介切面
  * **DefaultIntroductionAdvisor** 三个构造函数
  * DefaultIntroductionAdvisor(Advice) 通过一个增强创建的引介切面,引介切面将为目标对象增加对象中所有接口的实现
  * DefaultIntroductionAdvisor(DynamicIntroductionAdvice advice,Class cls) 通过一个增强和一个指定的接口类创建引介切面,仅为目标对象新增class接口的实现
  * DefaultIntroductionAdvisor(Advice advice,IntroductionInfo info) 通过一个增强和一个IntroductionInfo创建引介切面,目标类对象需要实现哪些接口由introductionInfo对象的getInterfaces()方法表示
####AspectJ正则表达式
![](https://i.imgur.com/V6AUIQL.png)
![](https://i.imgur.com/bwsePbN.png)

##Spring自动创建代理
* 基于BeanPostProcessor的自动代理创建器的实现类,将一些规则自动在容器实例化Bean时为匹配的Bean生成代理实例,主要分为三类:
  * 基于Bean配置名规则的自动代理创建器,允许为一组特定的配置名的Bean自动创建代理实例的代理创建器,实现类***BeanNameAutoProxyCreator***
  * 基于Advisor匹配机制的自动代理创建器,他会对容器中所有的Advisor进行扫描,**自动**将这些切面应用到匹配的Bean中(为目标Bean创建代理实例),实现类**DefaultAdvisorAutoProxyCreator**
  * 基于Bean中的AspectJ注解标签的自动代理创建器,为包含AspectJ注解的Bean自动创建代理实例,实现类**AnnotationAwareAspectJAutoProxyCreator**
####Spring代理注意事项
* jdk代理要保证该方法在接口中有声明,否则不会增强,且必须public或public final,不能是static
* cglib代理时,方法不能声明为final,static,private.换句话说被子类覆盖的才可以增强
* 同一个类中一个方法调用另个方法,被调用的方法不会被增强,可以使用专门接口来重复维护被同一类方法调用的方法使其不在一个类中,采用全局ApplicationContext再次输入本类?
* 如果不想使用上述解决方法则可以采用AspectJ,他采用编译期织入且不需要生成代理类避免final,static方法不能被覆盖的问题

##AspectJ
* 编程方式使用AspectJ:`AspectJProxyFactory` Spring方式:`AnnotationAwareAspectJAutoProxyCreator`
####AspectJ语法说明
* AspectJ根据描述对象不通可以分为4类型:
  * 方法切点函数:通过描述目标类方法的信息定义连接点
  * 方法入参切点函数:通过描述目标类入参的信息定义连接点
  * 目标类切点函数:通过描述目标类的信息定义连接点
  * 代理类切点函数:通过描述目标类的代理类的信息定义连接点
![](https://i.imgur.com/ed6mibW.png)
* **\*** 匹配任意字符,但它只能匹配上线文中的一个元素
* **..** 匹配任意字符,可以匹配上下文中的多个元素,但在表示类时,必须和*联合使用,而在表示入参时,则可以单独使用
* **+** 表示按类型匹配指定类的所有类,必须跟在类名后面,如com.fanyin.Waiter+ 匹配继承或扩展指定类的所有类,包含本身
* 支持上述所有通配符的 execution() within()等
* 仅支持"+"通配符: args() this() target()
* 不支持通配符: @args() @within() @target() @annotation
* 此外 args() this() target() @args() @within() @target @annotation这几个函数除了可以指定类名之外还可以指定变量名,并将目标对象的变量绑定到增强方法上
* 上述切点函数之间也可以进行逻辑运算
  * ||或or 后者是spring提供
  * &&或and 后者是spring提供
  * !或not 后者是spring提供
* execution(<修饰符>? <返回类型> <方法名> <方法参数> <异常类型>?) ?代表非必填
####AspectJ注解说明
* **@Before(value,argNames)** 前置增强
  * value:定义切点
  * argNames:由于无法通过java反射获取方法的入参名,所以如果在java编译时未启用调数信息,或者需要在运行期解析切点,就必须通过这个成员指定注解所标注增强方法的参数名(二者名字必须完全一样),多个参数逗号分开
* **@AfterReturning(value,pointcut,returning,argName)** 后置增强
  * value:定义切点
  * pointcut:表示切点的信息,如果显式指定pointcut则他会覆盖value的设定值,可以看做两者同义
  * returning:将目标对象方法的返回值绑定给增强的方法,即可以在增强方法中直接取到返回值,注意returing的名称必须和增强方法参数名一样,类似于JoinPoint
  * argNames:和上述一样
* **@Around(value,argName)** 环绕通知
* **AfterThrowing(value,pointcut,throwing,argName)** 异常增强 
  * throwing 将异常绑定到增强方法中,与returing一样
* **@After** final增强,不管是抛出异常还是正常退出该增强都会执行
* **@DeclareParents(value,defaultImpl)** 引介增强 
  * defaultImpl:默认的接口实现类
* **@Pointcut** 定义切点,其他注解可以复用该切点 
* **@Order** 指定增强的优先级
#### AspectJ连接点信息
* **JoinPoint** 目标类连接点对象 非环绕通知
  * getArgs():获取连接点方法运行时的入参列表
  * getSignature():获取连接点的方法签名对象
  * getTarget():获取连接点所在的目标对象
  * getThis():获取代理对象本身
* **ProcessdingJoinPoint** 环绕通知,该接口继承JoinPoint,新增如下方法
  * proceed():通过反射执行目标对象的连接点的方法
  * proceed(args[]):通过反射执行目标对象连接点处的方法,使用新参数代替旧参数
![](https://i.imgur.com/SPQcb9g.png)
#### spring事务

* 通过DataSourceUtils可以获取链接和释放链接,在有事务情况下不需要显式的释放,而在无事务情况下需要显式释放
* 使用TransactionAwareDataSourceProxy对数据源进行代理,数据源就有了对事务上下文感知的能力,从代理数据源中取connection与上述取效果一样,不会产生事务问题
##Spring缓存
####缓存策略
* **FIFO**(First In First Out):先进先出
* **LRU**(Least Recently Used):最久未使用的(距离现在最久的)
* **LFU**(Least Frequently Used):最近最少使用的(一段时间内使用频率最少的)
* **TTL**(Time To Live):存活期,从创建开始到到期的一个时间段
* **TTI**(Time To Idle):空闲期,一个数据多久没有被访问过就会被移除的时间段

##Netty权威指南

##JAVA编程思想
####运算符
* **关系运算符** < > >= <= != ==
* **逻辑运算符** && or !
* **按位运算符** ~ | & ^ |= &= ^= 
* **位移运算符** << >> >>>
* **三元if-else运算符**
  * << 左移: 能将运算符左边的运算对象向左移动运算符右侧指定的位数（在低位补 0）
  * >> 有符号右移:则将运算符左边的运算对象向右移动运算符右侧指定的位数 若值为正，则在高位插入0；若值为负，则在高位插入
  * >>> 无符号右移:与无符号右移相比 无论正负高位直接插入0
##Spring实战 第四版
* **DefaultServletHandlerConfigurer.enable()** 开启静态资源请求Servlet	
* @RequestMapping指定的方法,如果返回值是对象或者集合,且没有@ResponseBody,spring会根据请求路径来查找响应的视图(如果有"/"前缀会去掉),同时将返回值放入model中,不建议使用该方式,consumes参数用来过滤Content-Type指定类型的请求,produces参数用来过滤Accept指定类型的请求
* **ServletCompentScan** 用于扫描@WebFilter,@WebServlet,@WebListener注解,在Servlet3.0中可以使用
* **OncePerRequestFilter** 每次Request请求过滤一次(该接口主要为了兼容servlet2.3,在之前的老版本,Filter会过滤内部forward转发请求)
* **spring.session.cleanup.cron.expression** @Scheduled定时清除redis-session数据的表达式
* **DelegatingFilterProxyRegistrationBean** 通过委托代理模式进行注册Filter,Filter是被spring所管理,通过设置targetBeanName,然后从spring中获取该Filter Bean,init()方法由tomcat调用,代理类不做任何额外初始化,该类实现`ServletContextInitializer`接口,在springboot内嵌tomcat启动时会被调用
* **ServletRegistrationBean** 同`DelegatingFilterProxyRegistrationBean`类似,实现了`ServletContextInitializer`接口,在tomcat启动时,会注册自定义的Servlet Bean,springboot就是通过类注册`DispatcherServlet`的
* **ServletListenerRegistrationBean**  同`DelegatingFilterProxyRegistrationBean`类似,在tomcat启动时,注册自定义的`ServletContextListener` 由于springboot采用AnnotationConfigEmbeddedWebApplicationContext作为上下文,因此不需要额外注册`ContextLoaderListener`创建ApplicationContext,
* **FilterRegistrationBean** 与`DelegatingFilterProxyRegistrationBean`作用一样,区别:该类采用的非代理模式,Filter由调用者通过构造方法传入
##JMX
* `MBeanExporter` 可以将普通bean导出为MBean,在jconsole里面进行查看
* `MBeanInfoAssembler` 接口用来指定导出MBean的哪些方法
* `InterfaceBasedMBeanInfoAssembler` 是MBeanInfoAssembler的一种实现,用来指定实现了某个接口的Bean的导出
* `@ManagedResource` 基于注解形式,在类上使用
* `@ManagedOperation` 把方法暴露为MBean托管操作
* `@ManagedAttribute` 把Bean的属性暴露为Mbean托管属性

##Spring Security
* 执行过程通过`WebSecurityConfiguration` 生成一个特殊的Filter `FilterChainProxy`,该Filter自身维护一个`SecurityFilterChain`列表,该列表中又维护一个url<->List<Filter>对应关系的列表,同时`FilterChainProxy`本身实现了调用链,如果没有找到List<Filter>走默认的FilterChain,否则执行自身调用链
* `FilterChainProxy`对象创建时,会调用`WebSecurity`的performBuild()方法,通过performBuild()方法又调用`HttpSecurity`的performBuild()方法用来设置`SecurityFilterChain`列表

##JetCache
* 采用Spring Aop方式进行缓存注解方法拦截
* `@EnableMethodCache` 方法用于开启jetCache缓存注解:
   * 创建`CacheAdvisor`切面,已经设置好切入点`CachePointcut`与增强器`JetCacheInterceptor`
   * `CachePointcut`在首次执行时会将要增强的方法缓存到`ConfigMap`中的Map中
   * `CacheHandler`#invoke()方法为真实增强的业务逻辑
##深入浅出java内存模型

##java并发
* 轻量级锁的获取和释放过程 
![](https://i.imgur.com/jmsk0bD.png)
####红黑树
* 每个节点非红即黑
* 根节点为黑色
* 每个叶子节点为黑色。叶子节点为NIL节点，即空节点
* 如果一个节点为红色，那么它的子节点一定是黑色
* 从一个节点到该节点的子孙节点的所有路径包含相同个数的黑色节点
![](https://i.imgur.com/nhpiHFM.png)
* 左旋

![](https://i.imgur.com/YOL5vvF.gif)

* 右旋

![](https://i.imgur.com/ZRX6Ums.gif)

* HashMap

![](https://i.imgur.com/C4gdEqK.png)

* **HashMap源码说明**
  * tab[i = (n - 1) & hash]) 先减后取模,再赋值给i

## dubbo源码说明
> 将ServiceBean或者ServiceConfig等后缀的Bean或Config删除,将前一部分转为小写
> 同时dubbo加载service的配置信息时先在对应的ServiceBean或者ServiceConfig等方法中查找set方法
> 切分set后的属性名称并转为小写作为最后的property
> 即查找配置信息的前缀为dubbo.service
> 根据是否包含Id来确定是否以dubbo.service.#id.property或dubbo.service.property
> 然后在系统参数中查找System.getProptery()
> 如果没有查找到,再通过get方法进行查找,反射获取get的返回值,如果返回值为空,
> 查找用户是否设置了系统变量dubbo.properties.file属性,如果设置,则以该值作为配置文件名进行加载
> 如果没有设置,则加载默认的dubbo.properties文件
> 然后查找该配置文件中是否有dubbo.service.#id.property或dubbo.service.property

##Spring Boot 2.0企业应用实战

####启动过程
> * 检查是否为web环境(是否包含ConfigurableWebApplicationContext类)
> * 加载spring.factories中指定的ApplicationContextInitializer实现类(上下文初始化)
> * 加载spring.factories中指定的ApplicationListener实现类(事件监听)
> * 加载spring.factories中指定的SpringApplicationRunListener实现类并委托给SpringApplicationRunListeners类(默认唯一实现类EventPublishingRunListener,事件发布监听器)
> * 触发ApplicationListener中ApplicationStartedEvent监听事件
> * 环境配置,创建StandardServletEnvironment对象(web环境),设置args入参
> * 创建ApplicationContext(web环境默认AnnotationConfigEmbeddedWebApplicationContext类)
> * 设置上下文环境
> * 执行ApplicationContextInitializer.initialize方法
> * 注册springApplicationArguments(args参数封装对象)
> * 注册springBootBanner(打印banner)
> * 加载并注册启动类
> * 触发ApplicationListener的ApplicationPreparedEvent事件
> * ApplicationContext.refresh()
> * 执行ApplicationRunner.run()
> * 执行CommandLineRunner.run()
> * 触发ApplicationContext的ApplicationReadyEvent事件

####关键类
* `ConfigurationClassParser`
* `ConfigurationClassPostProcessor`
* `ComponentScanAnnotationParser`
* `ComponentScanBeanDefinitionParser`
* `CommonAnnotationBeanPostProcessor`

## JUC类库

> * `Vector`用来代替`ArrayList`实现线程安全,内部采用synchronized关键字实现
> * `Hashtable`用来代替`HashMap`实现线程安全,内部采用synchronized关键字实现
> * `CopyOnWriteArrayList` 内部维护`ReentrantLock` 在写操作时加锁,复制原数组,在新数组上进行操作,最后将新数组指向原数组
  	* 写操作多时比较耗费内存(额外复制一份数组)
  	* 只保证最终一致性,不能保证数据实时的一致性(遍历时,取原数组进行遍历)
  	


##基础算法

* **选择排序** 找到数组中最小的元素与第一个元素交换位置,然后在剩余元素中找到最小元素与数组中第二元素交换位置,依次执行
* **插入排序** 将数组中arr[i] 插入到 arr[0]~arr[i-1]中比它小的所有元素依次有序交换