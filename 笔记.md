1.InnoDB存储引擎
### 调用顺序在AbstractAutowireCapableBeanFactory.initializeBean()方法中实现:
  ``` 
**setAware->
InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation(实例化之前)->
实例化->
InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation->
InstantiationAwareBeanPostProcessor.postProcessPropertyValues(设置属性之前)->
BeanPostProcessor.postProcessBeforeInitialization(可对bean进行二次加工)-> 
InitializingBean.afterPropertiesSet -> 
bean.init-method -> 
BeanPostProcessor.postProcessAfterInitialization->
bean为prototype返回给调用者(由调用者维护声明周期),singleton放入缓存池,引用返回给调用者->
bean为singleton时,容器关闭实现了DisposableBean接口调用destroy方法->
bean.destroy_method(singleton才会触发)
  ```
> * InitDestroyAnnotationBeanPostProcessor 负责针对JSR250中PostConstruct,PreDestroy注解进行处理
> * AspectjWeavingEnabler,CustomAutowireConfigurer,ConfigurationClassPostProcessor这些为工厂的后处理器,为容器级别的在应用上下文装配配置文件后立即调用

### FactoryBean接口
   * 实现该接口可以直接通过new方式获取bean,类似@Bean
## Spring Boot
>  * `@ModelAttribute`注解可以将入参放入模型对象以便于渲染数据.ModelAttribute在方法时,会在执行处理前执行,将设置的value值作为key,返回值设置到model里面
>  * `@SessionAttribute`注解可以将某个属性暂存HttpSession中以便于在回话中反复使用
>  * `@MatrixVariable` 
>  * `@RequestBoby` 从request中的body中读取application/json application/text等对象同时绑定到响应的对象中
>  * `@Lazy` 在调用此属性的时候才会注入属性值,和autowired同时出现,且要注入的bean声明为@Lazy

 

## redis安装:

> * yum install binutils
> * yum install glibc
> * yum install glibc-kernheaders
> * yum install glibc-common
> * yum install glibc-devel
> * yum install gcc
> *  yum install make
> * yum install vim
> * make MALLOC=libc
> * cp redis-server,redis-benchmark,redis-cli,redis.conf到指定目录
> * cp utils/redis_init_script /etc/init.d/redis 增加 # chkconfig 2345 80 90
> * chkconfig redis on 开机启动
> * ./redis-server & 启动
> * ./redis-cli 客户端链接

### window-redis:
> * redis-server --service-uninstall
> * redis-server --service-install redis.windows.conf

###java安装:
> vim /etc/profile  
> JAVA_HOME=/usr/local/java  
> PATH=$JAVA_HOME/bin:$PATH  
> CLASSPATH=$JAVA_HOME/jre/lib/ext.jar:$JAVA_HOME/lib/tools.jar  
> export PATH JAVA_HOME CLASSPATH  

> * window拷贝到centos中文件格式转换
> * :set ff? 查看文件内容格式
> * :set ff=unix 强制转换

### Google Guava

### Spring Boot
* @ConditionalOnBean：当前容器有指定Bean的条件下。
* @ConditionalOnClass：当前类路径下有指定的类的条件下。
* @ConditionalOnExpression：基于SpEL表达式作为判断条件。
* @ConditionalOnJava：基于JVM版本作为判断条件。
* @ConditionalOnJndi：在JNDI存在的条件下查找指定的位置。
* @ConditionalOnMissingBean：当容器里没有指定Bean的情况下。
* @ConditionalOnMissingClass：当类路径下没有指定的类的条件下。
* @ConditionalOnNotWebApplication：当前项目不是WEB项目的条件下。
* @ConditionalOnProperty：指定属性是否有指定的值。
* @ConditionalOnResource：类路径是否有指定的值。
* @ConditionalOnSingleCandidate：当指定Bean在容器中只有一个，或者虽然有多个但 是指定首选的Bean。
* @ConditionalOnWebApplication：当前项目是WEB项目的条件下。

### Spring Boot初始化的listener如下:
* ConfigServerBootstrapApplicationListener- min+4
* FileEncodingApplicationListener- max
* AnsiOutputApplicationListener- min+11
* ConfigFileApplicationListener- min+10
* DelegatingApplicationListener- 0
* ClasspathLoggingApplicationListener- min+21
* LoggingApplicationListener- min+20
* BackgroundPreinitializer- min+21
* BootstrapApplicationListener- min+5
* LoggingSystemShutdownListener- min+6
### 过滤一下部分
* ClearCachesApplicationListener
* ParentContextCloserApplicationListener
* LiquibaseServiceLocatorApplicationListener
* RestartListener

### Spring Boot初始化的initializer如下:
* ConfigurationWarningsApplicationContextInitializer
* ContextIdApplicationContextInitializer
* DelegatingApplicationContextInitializer
* ServerPortInfoApplicationContextInitializer
* SharedMetadataReaderFactoryContextInitializer
* AutoConfigurationReportLoggingInitializer



### Spring Boot Actuator说明:
![](https://i.imgur.com/0GQwfRW.png)

### spring启动基本说明:

* ConfigurationClassPostProcessor负责全局解析注解
* ConfigurationClassParser在上述类中负责真实解析,分类返回类定义结果
* 在ConfigurationClassPostProcessor注册bean



### JVM 三特性
* 原子性
* 可见性
* 有序性

**红黑树:**

1.节点是红色或黑色。

2.根节点是黑色。

3.每个叶子节点都是黑色的空节点（NIL节点）。

4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)

5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

![](https://i.imgur.com/r3kP1c9.png)

### 位与运算 [原文件地址](https://github.com/wangyanbing/carry/blob/master/src/main/java/com/beetl/bit/BitWeiYunSuan.java)
![](https://i.imgur.com/Mp6U1xi.png)

### quartz表达式说明

![](https://i.imgur.com/MOUISVd.png)
----------
### java NIO

Buffer 属性说明:
 
* > capacity:容量,buffer最多存放的元素数量;
* > limit:可以使用的上限,创建时该值与capacity值一样,例如初始容量为100,现在往里面写入20个元素数据后,再读取limit 变为20;
* > position:当前所操作元素所在的索引位置 position从0开始,随着get,put方法自动更新
* > mark:用来暂时保存position的值,例如如果当前position位置为10,需要读取position为15的值,这个时候mark一下,而后设置position值为15读取即可,再调用reset后position值即恢复为10
> mark <= position <= limit <= capacity

* > clear:初始化limit,position,mark,让limit = position position=0 mark = -1
* > flip:保存数据时 保存一个数据postion+1,保存完后如果想读取出来就需要将最好postion位置让给limit,然后将position位置设置为0这个就可以读取所有保存的数据了


### Tomcat启动时序图
![](https://i.imgur.com/P2ySS27.png)

###Spring源码解析
* **AliasRegistry** 定义了对alias的增删改查方法
* **SimpleAliasRegistry** 使用Map对alias进行缓存并对AliasRegistry进行了实现
* **SingletonBeanRegistry** 定义对单例的注册和获取
* **BeanFactory** 定义获取bean及bean属性的方法
* **DefaultSingletonBeanRegistry** 对SingletonBeanRegistry接口进行了实现
* **HierarchicalBeanFactory** 继承BeanFactory,增加对父Factory的支持
* **BeanDefinitionRegistry** 继承AliasRegistry,额外定义了对BeanDefinition的增删改查方法
* **FactoryBeanRegistrySupport** 继承DefaultSingletonBeanRegistry,增加了对FactoryBean的支持
* **ConfigurableBeanFactory** 提供了对BeanFactory配置的方法
* **ListableBeanFactory** 根据各种条件获取bean的配置信息
* **AbstractBeanFactory** 综合FactoryBeanRegistrySupport与ConfigurableBeanFactory的功能
* **AutowireCapableBeanFactory** 提供了创建Bean,自动注入,初始化以及应用bean的后处理器
* **AbstractAutowireCapableBeanFactory** 综合AbstractBeanFactory并对接口AutowireCapableBeanFactory进行了实现
* **ConfigurableListableBeanFactory** BeanFactory配置清单,指定忽略类型及接口
* **DefaultListableBeanFactory** 综合上面所有功能,主要对bean注册后的处理
* **XmlBeanFactory** 继承DefaultListableBeanFactory,主要从xml读取BeanDefinition,增加了XmlBeanDefinitionReader类型的reader属性,使用reader属性对资源文件进行读取和注册
* **BeanDefinitionReader** 定义资源文件读取并转换为BeanDefinition的各种功能

### Spring Mvc源码解析
##### DispactcherServlet说明:

* **XXXAware** 在spring中表示对XXX可以感知,通俗解释:如果某个类想使用spring的一些东西就可以通过XXXAware告诉spring,spring在看到后会送给你,而接收的方式是通过实现接口的唯一方法set-XXX.例如一个类想使用当前的ApplicationContext我们只需要让他实现ApplicationContextAware接口然后实现唯一的方法void setApplicationContext(ApplicationContext context)就可以了,spring会自动调用这个方法将ApplicationContext传递给我们,我们只需要接收即可
* **EnvironmentCapable** 具有Environment的能力,也就说可以提供Environment,所以他的唯一方法是Environment getEnvironment(),用于实现EnvironmentCapable接口的类,告诉spring它可以提供Environment,当spring需要用Environment的时候,spring就会调用getEnvironment跟他要
* **BeanWrapper**: 它可以直接修改一个类的属性

* **HandlerExceptionResolver** 异常处理器解析器,detectAllHandlerExceptionResolvers来确认是通过类型加载HandlerExceptionResolver(所有的)还是通过handlerExceptionResolver名称+类型来加载(指定名称类型的),如果没有定义默认会注册在dispatcherServlet.properties文件中定义的以下三个:AnnotationMethodHandlerExceptionResolver(3.2后过时),ResponseStatusExceptionResolver,DefaultHandlerExceptionResolver
* **RequestToViewNameTranslator** 如果处理器返回的view为空时,从request中获取viewName,默认实现在dispatcherServlet.properties中配置的DefaultRequestToViewNameTranslator
* **MethodIntrospector#selectInvocableMethod** 根据给定方法查找对应类上是否存在该方法,如果方法所在类与目标类一样则直接返回该方法,否则查询父类方法如果找到则返回如果找不到在目标类中查找,如果查找不到则跑异常
* **RequestMappingHandlerAdapter** 请求处理器适配器. 1 参数绑定 2 调用methodHandler 3 返回组装modelView 
* **ModelAndViewResolver** 自定义视图解析器,实现该接口后需要注入到RequestMappingHandlerAdapter里面,默认的supportsReturnType返回true,但在HandlerMethodReturnValueHandler中排在最后,即当其他返回值处理器无法匹配时才执行该项
* **HandlerMethodArgumentResolver** 参数解析器,一般实现类XXXMethodArgumentResolver 或者XXXMethodProcessor 前者是参数解析器 后者除了解析参数还可以处理对应类型的返回值数据,即同时实现了[HandlerMethodReturnValueHandle](#handlerMethodReturnValueHandle) XXX表示要解析的参数类型.最后还有XXXAdapter 主要是兼容WebArgumentResolver,用来处理自定义的解析方法
* <span id="handlerMethodReturnValueHandle">**HandlerMethodReturnValueHandle**</span>返回值类型处理器
* **AbstractNamedValueMethodArgumentResolver**  解析namedvalue类型参数(name参数如:cookie,requestParam,requestHeader,pathVariable等)的基类,主要功能:获取name,resolverDefaultValue,handleMissingValue,handleNullValue,调用模板方法resolveName,handleResolvedValue具体解析
* 

### MAVEN
filter说明:

* filter会在打包编译的时候将properites,xml文件中${} 替换为profile配置的properties的信息,注意 需要开启<filtering>true</filtering>

#### JAVA
###### 反射:
* parameter.isNamePresent 用来确定编译时是否包含参数信息,如果不包含则在.getName()时,参数会以arg0,arg1等依次排列显示

###### Bridge method 桥方法:
* 在定义泛型的接口方法里,由于方法没有指定参数类型,因此在调用的时候可以是任意类型,但实际调用时却是实现方法所指定的参数类型,这个时候就会出现调用错误的问题,因此虚拟机在编译的时候会对接口的泛型的方法创建两个方法,除了实现接口方法指定的参数外,还会创建一个Object类型作为参数的方法(注意实现的方法需要为public),而这个额外生成的方法会强制将参数转换为对应的类型,最终会调用真实实现的接口方法.所以在指定泛型的类里面如果泛型参数类型传递错误,在强制转换的时候会异常

###### 四舍五入
* **ROUND_UP**：远离零方向舍入，即向绝对值最大的方向舍入，只要舍弃位非0即进位。
* **ROUND_DOWN**：趋向零方向舍入，即向零方向靠拢，注意所有的位都舍弃，不存在进位情况。
* **ROUND_CEILING**：向正无穷方向舍入，若为正数，舍入行为类似ROUND_UP；若为负数，则类似ROUND_DOWN。注意：* Math.round()方法即为此模式。
* **ROUND_FLOOR**：向负无穷方向舍入，若为正数，舍入行为类似ROUND_DOWN；若为负数，则类似ROUND_UP。
* **HALF_UP**：最近数字舍入(5进)，这是最经典的四舍五入模式。
* **HALF_DOWN**：最近数字舍入(5舍)，在四舍五入中，5是进位的，而在HALF_DOWN中是舍弃不进位的。
* **HALF_EVEN**：银行家算法，主要运用于商业运算的项目中，以确保相关数据计算的准确性。

####### java虚拟机运行时数据区说明
![](https://i.imgur.com/MRZD9Sb.png)

* **程序计数器** 一块很小的内存区域,当前线程所执行的字节码的行号指示器,如果执行的是native方法这个计数器是undefined,此内存区域是java虚拟机规范中没有任何OutOfMemoryError情况的区域
* **java虚拟机栈** 是线程私有的,与线程周期相同,描述的是java方法执行的内存模型,每个方法执行的同时会创建一个栈帧用来存储局部变量表,操作数栈,动态链接,方法出口等信息.每个方法从开始到执行完成的过程,都对应着一个栈帧在虚拟机栈中的入栈到出栈的过程,通常说的"栈"就是讲的虚拟机栈,或者说是虚拟机栈中的局部变量表部分,**局部变量表** 存储在编译期已知的基本类型(boolean,byte,int,long,short,float,double,char)以及对象引用(reference类型,它不等同于对象本身,可能是一个指向对象引用的地址,也可能是指向一个代表对象的句柄或者与该对象相关的位置)和returnAddress类型(指向一个字节码执行的地址).其中64位长度long,double会占用2个局部变量空间其余数据类型占用1个,局部变量所需要的内存空间在编译期间完成分配,当进入一个方法时,这个方法所需要在帧中分配多大的局部变量空间是完全确定的,在方法运行期间不会改变局部变量表的大小.在java虚拟机规范 **如果线程请求的栈的深度大于虚拟机所允许的深度将抛StackOverflowError异常,如果虚拟机栈可以动态扩展,如果在扩展时无法申请到足够的内存,就会抛OutOfMemoryError异常**(当前大部分的java虚拟机都可以动态扩展,只不过java虚拟机规范也允许固定长度的虚拟机栈)
* **本地方法栈** 与虚拟机栈作用相似,他们之间区别不过是虚拟机栈为虚拟机执行java方法服务,本地方法栈为虚拟机使用到的native方法服务(虚拟机规范中对本地方法栈所使用的语言,使用方法与数据结果没有强制规定,因此具体的虚拟机可以自由实现它,Sun HotSpot虚拟机就将本地方法栈与虚拟机栈合并成一个),与虚拟机栈一样 本地方法栈也会抛StackOverflowError及OutOfMemoryEerror
* **java堆** 是java虚拟机中所管理的内存中的最大一块,是所有线程共享的一块内存区域,在虚拟机启动时创建.该内存区域唯一作用:存放对象实例,几乎所有的对象实例都在这里分配内存.**(但随着JIT编译器的发展与逃逸分析技术的成熟,栈上分配,标量替换优化技术会导致一些微妙变化)** java堆是垃圾收集器管理的主要区域.因此也被成为GC堆.从内存回收的角度来看,由于现在收集器基本采用分带收集算法,所以java堆中还可以细分为新生代,老年代,再细一点的有Eden空间 From Survivor空间 To Survivor空间等.从内存分配角度来看,线程共享的java堆中可能划分为多个线程私有的分配缓冲区(Thread Local Allocation Buffer TLAB)
* **方法区** 与堆一样是各个线程共享的内存区域,它用于存储已经被虚拟机加载的类的信息,常量,静态变量,即时编译器编译后的代码等数据.根据虚拟机规范,当方法区无法满足内存分配需求时,将OutOfMemoryError异常
* **运行时常量区** 是**方法区的**一部分,class文件除了有类的版本,字段,方法,接口等描述信息外,还有常量池(Constant Pool Table),用来存放编译期生成各种字面量和符号引用,这部分在类加载后将在方法区的常量池中存放.java虚拟机对class文件的每一部分(包含常量池)的格式都有严格的规定

* **-XX:+/-UseTLAB**设置是否使用TLAB模式分配(每个线程在java堆中预先分配一小块内存,如果线程要分配内存就在自己所在TLAB上分配)
* **对象头** 包含两部分:一部分用于储存自身的运行时数据,如HashCode,GC分代年龄,锁状态标志,线程持有锁,偏向线程ID,偏向时间戳这部分数据的长度在32位和64位虚拟机中分别为32bit和64bit(称为Mark Word),对象需要存储的运行时的数据很多一般都超过32位或64位,因此Mark Word被设计成一个非固定的数据结构以便于在极小的空间存储尽量多的信息.另一部分是类型指针,即对象指向它的类元数据的指针,虚拟机通过这个指针来确定这个对象是那个类的实例
* **-Xms20m**最小堆内存
* **-Xmx20m** 最大堆内存 两个设置为一样即可避免堆自动扩展
* **-Xoss** 本地方法栈
* **-Xss** 设置栈的大小 由于HotSpot虚拟机将 本地方法栈及虚拟机栈合并,因此-Xoss是无效的
* **-Xmn10m** 堆里面新生代内存
* 操作系统对每个进程的内存是有限制的 window 32位系统最大分配是2G,因此减去Xmx(最大堆内存),再减去MaxPermSize(最大方法区容量),程序计数器很小可以忽略.如果虚拟机本身进程消耗的内存不计算内剩余的内存就被虚拟机栈与本地方法栈所占用,**每个线程分配的栈容量越大,可建立的线程数就越少,建立线程容易把剩余的内存消耗掉**
* **-XX:PermSize=20m** 设置方法区的最小值
* **-XX:MaxPermSize=20m** 设置方法区的最大值
* 在1.6以及之前的版本常量池分配在永久代内,因此可以通过上述两个设置来间接限制常量池的容量
* **-XX:MaxDirectMemorySize=100m** 指定DirectByteBuffer所能分配的空间,如果未设置 会被jvm默认为最大堆内存,一般在NIO中等使用
* **-XX:+PrintGCDetails** 收集GC日志
* **-verbose:gc** 收集GC日志 与上面类似
* **-XX:PretenureSizeThreshold** 令大于这个设置值的对象直接在老年代分配.这样做的目的避免在Eden区以及两个Survivor区之间发生大量的内存复制 **该值只对Serial与ParNew两种收集器有效** Parallel Scavenge收集器不认识该参数
* **-XX:SurvivorRatio=8** 堆中Eden与Survivor比例值
* **-XX:+PrintGCApplicationStoppedTime** 打印GC手机停顿时间
* **-XX:+PrintGCDateStamps** 打印GC收集时间
* **-Xloggc:gclog.log** 写入gc日志到文件中
* **-XX:+PrintReferenceGC** 用来跟踪系统内的(softReference)软引用，(weadReference)弱引用,(phantomReference)虚引用，显示引用过程
* **-XX:+DisableExplicitGC** 屏蔽掉显式调用System.gc();因为该操作大部分情况下会触发Full GC
* **-XX:+UseConcMarkSweepGC** 启用CMS收集器,新生代使用ParNew收集器,老年代使用CMS收集器 **默认关闭**
* **-XX:+UseParNewGC** 启用ParNew收集器,该收集器是在CMS启用后 默认新生代收集器(在启用CMS后可不用填写该参数) 老年代使用串行收集器
* **-XX:+UseSerialGC** 启用串行垃圾收集器 老年代新生代都是用 **默认关闭**
* **-XX:+UseParallelOldGC** 为老年代与新生代都使用并行清除的垃圾收集器 **默认关闭**
* **-XX:+UseParallelGC** 为新生代启用并行清除,老年代使用单线程Mark-Sweep-Compact的垃圾收集器
* **-XX:CompileThreshold=10000** 设置方法被调用多少次后会通知即时编译器提交一个该方法的代码编译请求![](https://i.imgur.com/RjrqtOo.png)
* **-XX:-UseCounterDecay** 不设置CompileThreshold,方法计数统计并不是方法被调用的绝对次数,而是一个相对的执行频率,即一段时间内方法被调用的次数,当超过一定的时间限度,如果方法调用次数仍然不足以让它提交给即时编译器编译,那么这个方法的调用计数器就会减半这个过程称之为方法计数器热度的衰减(CounterDecay),而这段时间就称之为此方法统计的半衰减周期(Counter Half Life Time).可以通过该参数来关闭热度衰减,让方法计数器统计方法被调用的绝对次数,这样,只要系统运行时间足够长,几乎所有的代码都会编译为本地代码.
* **-XX:CounterHalfLifeTime** 设置半衰减周期的时间 单位为秒
![](https://i.imgur.com/sUrYLSP.png)
* **-XX:-BackgroundCompilation**,如果上述编译达到条件,代码编译器未编译完成之前,都仍按照解释方式继续执行,而编译动作会在后台的编译线程中执行,设置该参数后将禁用后台编译.即一旦达到JIT编译条件,执行线程会向虚拟机提交编译请求后将会一直等待,直到编译完成后,开始执行编译器输出的本地代码
* **-XX:+PrintCompilation** 开启虚拟机在即时编译时,将编译为本地代码的方法打印出来 "%"为回边计数器触发OSR的编译
* **-XX:+PrintInlining** 输出方法内联信息 貌似需要开启 **-XX:+UnlockDiagnosticVMOptions** 参数才行
#####堆详解
* **Minor GC** 新生代GC 比较频繁
* **Major GC(Full GC) 老年代GC 出现Major GC时至少进行一次Minor GC(非绝对 Parallel Scavenge收集器会忽略),一般Major GC比Minor GC满10倍以上
* 在绝大多数情况下对象会在新生代Eden区中分配,当Eden区没有足够的空间进行分配时,虚拟机将发起一次Minor GC
* 虚拟机给每个对象定义了一个"age"计数器,如果对象生成在Eden区,经过Minor GC后扔存活,并且Survivor区能够容纳下,将会被移入Survivor区并且年龄加1,每经过一次Minor GC 年龄都会增加一岁,当增加到一定年龄后会被移入老年代(默认阀值是15,可通过设置**-XX:MaxTenuringThreshold=18**设置阀值)
* **PerNew** 收集器采用的是复制算法,该算法建立在绝大部分对象都是朝闻夕死的特性上,如果对象过多把这些对象复制到Survivor上 GC时间会比较长,而且一般空间比例Eden:Survivor为8:1
###### JDK监控与故障处理工具
* **jps**  JVM Process Status 显示系统内所有的HotSpot虚拟机进程,参数说明:
  1. **-q** 只输出LVMID(进程的本地虚拟机唯一ID:Local Virtual Machine Identifier)省略主类的名称
  2. **-m** 输出虚拟机进程启动过时传递给主类main()函数的参数 
  3. **-l** 输出主类的全名,如果是jar的输出jar路径
  4. **-v** 输出虚拟机进程启动时JVM的参数
* **jstat** JVM Statistics Monitoring Tool用于收集HotSpot虚拟机各方面的运行数据,它可以显示本地或者远程虚拟机进程中的类装载,内存,垃圾收集,JIT编译等运行数据,在没有GUI图形界面的服务器环境上,该工具是运行期定位虚拟机性能问题的首选工具.参数格式 jstat [option vmid [interval[s|ms] [count]] ] **注意** 如果是本地虚拟机则vmid与LVMID一致,如果是远程虚拟机进程那么VMID格式应当**[protocol:][//]lvmid[@hostname[:port]]/servername** interval是查询间隔,count是查询次数 例如每250毫秒查询一次2764的垃圾回收情况 一共查询20次则:jstat -gc 2764 250 20 省略这两个参数则默认只查一次,option参数如下:
  1. **-class** 监控类装载,卸载数量,总空间及类装载所耗费的时间
  2. **-gc** 监控java堆状况,包括Eden区 两个Survivor区,老年代永久代的容量,已用空间,GC时间合计等信息
  3. **-gccapacity** 监控内容与-gc基本相同,但输出主要关注java堆各个区域使用到的最大,最小空间
  4. **-gcutil** 监控内容与-gc基本相同,但输出主要关注已使用空间占总空间的的百分比
  5. **-gccause** 与gcutil基本一样,但会额外增加输出导致上次GC产生的原因
  6. **-gcnew** 监控新生代GC状况
  7. **-gcnewcapacity** 与gcnew基本相同,输出主要关注使用到的最大,最小空间
  8. **-gcold** 监控老年代GC状况
  9. **-gcoldcapacity** 与gcold基本一样,输出主要关注使用到的最,最小空间
  10. **-gcpermcapacity** 输出永久代使用的最大,最小空间
  11. **-compiler** 输出JIT编译器编译过的方法,耗时等信息
  12. **-printcompiklation** 输出已经被JIT编译的方法
  
   总结:关于-gc 参数说明 

	* S0 S1代表新生代Survivor1 Survivor2区已使用的的百分比 
	* E 代表新生代Eden区 
	* O 代表老年代
	* P 永久代(Permanent) 
	* YGC 程序启动后发生的Minor GC次数 
	* YGCT Minor GC总耗时时间 
	* FGC 程序启动后总
	*  GC次数 
	* FGCT Full GC总耗时时间 
	* GCT 所有GC总耗时时间
  
* **jinfo** Configuration Info for Java 显示虚拟机配置信息 jinfo [option] pid
	
	* ** 查询虚拟机参数 jinfo -flag CMSInitiatingOccupancyFranction 144
	
	
* **jmap** Memory Map for Java生成虚拟机内存转储快照(heapdump文件)
* 
* **jhat** JVM Heap Dump Browser 用于分析heapdump文件,它会建立一个Http服务器,让用户在浏览器上查看分析结果
* **jstack** Stack Trace for Java 显示虚拟机的线程快照


###java类文件属性
* 头四个字节代表class属性文件,(十六进制0xCAFEBABE)称为魔数,用来辨别文件的类型(因为扩展名可以更改不准确)
* 5-6字节代表次版本号
* 7-8字节代表主版本号
* 9字节常量池数量 常量池主要存放两大类:字面量Literal与符号引用(Symbolic Reference),字面量比较接近java语言层面的常量概念,如文本字符串,声明为final的常量值,而符号引用属于编译原理方面的概念,包括一下三类常量:
   * 类与接口的全限定名
   * 字段的名称与描述符
   * 方法的名称与描述符


###类加载器
* 针对同一个类进行加载,如果选择的加载器不一样,产生的对象也会不一样 instanceof 结果为false

######1.8日期工具类
* ChronoUnit:类可用于在单个时间单位内测量一段时间，例如天数或秒。
* Duration
* Period











#### Mysql
###### explain分析:
* **id** SELECT识别符。这是SELECT的查询序列号 
* **select_type** 查询类型如下:

 > * 1.SIMPLE: 简单查询 不使用union或子查询 
 > * 2.PRIMARY: 最外层的查询
 > * 3.UNION: UNION中的第二个或后面的SELECT语句
 > * 4.DEPENDENT UNION: UNION中的第二个或后面的SELECT语句,取决于外面的查询
 

#### Mybatis

* 与spring进行整合时,basePackage支持 **,** **;** **空格** **回车符** 进行分割多个包
* **MapperScannerConfigurer** 实现BeanDefinitionRegistryPostProcessor接口在postProcessBeanDefinitionRegistry方法中来初始化相关mybaits工作,例如通过定义ClassPathMapperScanner来确定扫描的包路径

#### java基础
String.lastIndexOf(str,fromIndex); 指在字符串0~fromIndex之间最后一次出现str的索引位置
######线程
* 线程的5个状态,在任意一个时间点,一个线程只能有且只有一种状态:
* **新建(New)** 创建后尚未启动的线程处于这种状态
* **运行(Runable)** Runable包括了操作系统状态中的Running与Ready,也就是说处于此状态的线程可能正在执行,也可能在等待CPU为它分配执行时间
* **无限期等待(Waiting)** 处于这种状态的线程不会被分配CPU执行时间,他们要等待被其他线程显式唤醒.以下几种会让线程无限期等待:
	* 没有设置Timeout参数的Object.wait()方法
	* 没有设置Timeout参数的Object.join()方法
	* LockSupport.park()方法
* **限期等待(Timed Waiting)** 处于该状态的线程也不会被分配CPU执行时间,不过无效等待其他线程显式唤醒,在一定时间后他们将有系统自动唤醒,以下几种会让线程限期等待:
	* Thread.sleep()
	* 设置了timeout参数的Object.wait()方法
	* 设置了timeout参数的Object.join()方法
	* LockSupport.parkNanos()方法
	* LockSupport.parkUntil()方法
* **阻塞(Blocked)** 线程被阻塞了,"阻塞状态"与"等待状态"的区别是,阻塞状态在等待着获取到一个排他锁,这个事件将在另一个线程放弃这个锁的时候发生,而等待状态则是等待一段时间或者唤醒动作的发生.在程序等待进入同步区域的时候,线程将进入这种状态
* **结束(Terminated)** 已终止线程的线程状态,线程已经结束执行
* BigDecimal.compareTo(BigDecimal) 如果第一个大于第二个返回 1 第一个等于第二个返回 0 第一个小于第二个返回 -1

#### 泛型
* public <T extends List,V extends List,R extends List> String say(T abc, V v,R r) 返回值前面的泛型强制确定入参的值的类型

### java规范
* 规范要求lock,unlock,read,load,assign,use,store,write 8个操作为原子性

## 深入迁出JAVA内存



## 设计模式之禅


##实战Java高并发程序设计

* **饥饿** 线程优先级可能太低,导致无法获取资源.还有可能是另一个线程长时间占用资源导致其他需要该资源的线程无法执行
* **活锁** 两个线程主动释放资源给他人使用,导致资源不断在两个线程之间跳动,而没有线程可拿到资源执行
* **scheduleAtFixedRate** 线程池周期性执行某个任务,开始于指定的延迟时间后,以给定的周期,循环执行
* **scheduleWithFixedDelay** 线程池周期性执行某个任务开始于指定的延迟时间后,以给定的周期,在上个任务结束+周期时间循环执行
### CAS 
* **AtomicReference** 封装了对象级别的CAS操作 AtomicInteger则是Integer级别的.针对cas操作时,如果对象在执行cas之前已经改变且又变回来,则无法被感知到,即cas操作无法正确的判断当前数据的状态
* **AtomicStampedReference** 与上述不同,该类带有时间戳状态,即在更新对象值的时候同时也必须更新时间戳
* **AtomicIntegerArray** **AtomicLongArray** **AtomicReferenceArray** 可用的原子数组
* **Unsafe.arrayBaseOffset()** 获取数组第一个元素的偏移量
* **Unsafe.arrayIndexScale()** 获取数组中一个元素的大小
* 数组明面上的大小将会是 偏移量+每个数组的大小*数组的长度(offset + scale * Array.length)
### CLH锁


##Spring基础 JAVA EE开发的颠覆者


* **DI** 依赖注入,容器负责创建对象和维护对象之间的依赖关系
* **@Value**说明:
  * @Value("ergehenmeng") 字符串注入
  * @Value("#{systemProperties['os.name']}") 系统属性注入
  * @Value("#{T(java.lang.Math).random() * 100 }") 运算方法注入
  * @Value("#{demoService.another}") 其他bean属性注入 demoService是其他的一个bean another为其属性
  * @Value("classpath:com/fanyin/text.txt") 文件注入
  * private Resource text;
  * @Value("${book.name}")配置文件属性注入
* **@PostConstruct** 构造方法执行完之后执行 JSR250 与Bean(init="xxxMethod")一样
* **@PreDestroy** 在Bean销毁之前执行 JSR250 与Bean(destroy="xxxMethod")一样
* **@Profile** 注解类或方法,在不同的情况下初始化不同的bean.在servlet2.5及之前需要在web.xml中配置,之后配置如下:
![](https://i.imgur.com/qxDvdmL.png)
* **spring事件** 为bean与bean之间消息通讯提供了支持,当一个bean处理完一个任务之后,希望另一个bean做响应的处理,则需要另一个bean监听当前bean发出事件
  * 自定义事件 实现ApplicationEvent接口;
  * 定义事件监听器 实现ApplicationListener;
  * 使用容器发布事件ApplicationContext.publishEvent
* **Spring Aware** 使普通bean感知容器存在,使用这些接口,bean将会和spring框架耦合
  * BeanNameAware 获取容器中bean的名称
  * BeanFactoryAware 获取当前beanFactory
  * ApplicationContextAware* 获取当前application context
  * MessageSourceAware 获取message source,可以获取文本信息
  * ApplicationEventPublishAware 应用事件发布器,可以发布事件
  * ResourceLoaderAware 获取资源加载器,可以加载外部资源文件
* **TaskExecutor** 基于线程池的"任务执行器" 实现AsyncConfigurer的getAsyncExecutor方法来定义TaskExecutor
* **计划任务** 
  * 3.1之后只需要开启@EnableScheduling即可,在需要执行计划任务的方法上注解@Scheduled,声明这是一个计划任务
* **@Conditional** 
  * spring4.0提供了更高级的基于条件的创建Bean的方法
* **@ImportResource** 加载xml配置文件
* **@Import** 加载单个类配置,或者普通bean或者ImportSelector等
* **@ConfigurationProperties** 基于类型安全的配置方式 
* **@PropertySources** 加载多个properties文件,java 1.8支持同一个注解在一个类上重复定义的,因此可以使用@PropertySource加载多个properties
* **spring.profiles.active** 用来配置生产环境,开发环境等,命名方式: application-*(dev,pro).properties
* 将静态文件index.html放置到如下目录,当访问项目根目录时会直接映射(前提不进行额外的拦截操作).同时网站logo放在以下目录会直接生效
  * classpath:/META-INF/resources/index.html
  * classpath:/resources/index.html
  * classpath:/static/index.html
  * classpath:/public/index.html
* **@SpringApplicationConfiguration** 单元测试注解 指定application启动类
* **spring-actuator** 监控模块 
  * ip:port/actuator
  * ip:port/autoconfig
  * ip:port/beans
  * ip:port/dump
  * ip:port/configprops
  * ip:port/health
  * ip:port/info
  * ip:port/metrics
  * ip:port/mappings
  * ip:port/shutdown 默认是关闭的 endpoints.shutdown.enabled=true开启 支持post请求  management.port=8081指定端口
  * ip:port/trace
  * endpoints.beans.id=mybean 针对上述可指定访问的地址
* **@AutoConfigureBefore** 在某个配置之前执行
* **@AutoConfigureAfter** 在某个配置完成之后执行

## Docker
* docker search <镜像名称.版本号>  从镜像服务器中查找镜像
* docker pull <镜像名: tag> 拉取镜像
* docker build -t <镜像名><Dockerfile路径> 创建镜像,需编写脚本
* docker imamges 查看所有的镜像
* docker rmi <镜像名> 删除镜像
* docker run -name 容器名 -d -p 内部端口号:外部端口号 镜像名<.版本号>  
  * -a 指定标准输入内容类型
  * -d 后台运行容器并返回id
  * -i 以交互模式运行容器
  * -t 为容器重新分配一个伪输入终端 通常与-i同时使用
  * --name 为容器指定一个名称
  * --dns 使用容器的dns服务器 默认与宿主一致
  * --dns-search 指定容器dns搜索域 默认与宿主一致
  * -h 指定容器的hostname
  * -e username设置环境变量
  * --env-file=[]从指定文件读取环境变量
  * --cpust="0-2"
* docker logs -f <容器名或id>
* docker ps 查看正在运行的容器
* docker rm $ (docker -a -q) 删除所有容器
* docker rm <容器名或ID> 删除一个容器
* docker stop <容器名或ID> 停止一个容器
* docker kill <容器名或id> 杀死一个容器
* docker start <容器名或id> 启动一个容器

##精通Spring+4.x企业应用开发实战
* **spring Resource**接口支持的地址前缀
  * classpath: 类路径加载 classpath:与classpath:/同价
  * file: 从文件系统装载资源,可以是相对路径也可以是绝对路径
  * http:// 从web服务器加载资源
  * ftp://从ftp服务器加载资源
  * 没有前缀: 根据ApplicationContext的具体实现类采用对应类型的Resource
  * classpath*: 针对多jar或者文件系统拥有相同的包名,classpath:只会在第一个加载的包路径下进行查找,而classpath*:则会扫描所有的包路径
* Ant风格的资源地址通配符
  * ? 匹配文件名中的一个字符
  * * 匹配文件名中的任意字符
  * ** 匹配多层路径
* **ContextLoaderListener** spring方法 实现了ServletContextListener用来监听ServletContext初始化和销毁
* **RequestContextListener** spring方法 实现了ServletRequestListener用来监听ServletRequest请求初始化和销毁
* **RequestHandlerEvent** 与web应用相关的事件,当一个Http请求被处理后,产生该事件,只有定义了DispatchServlet时才产生改事件,它有两个子类分别代表Servlet与Portet的请求事件
* **ApplicationContextEvent** 容器时间,有四个子类,分别是启动,刷新,停止,关闭的事件

##AOP概论
* **连接点(JoinPoint)** 程序执行的某个特定位置,通俗讲就是要使用aop要增强的方法的什么地方(之前,之后,异常等)
* **切点(Pointcut)** 相当于要作用方法的条件,即对哪些方法进行增强
* **增强(Advice)** 要增加的aop业务代码,即在目标类上增加的代码
* **目标对象(Target)** 要增强的目标类
* **引介(Introduction)** 是一种特殊的增强,它为类添加一些属性和方法,这样即使一个业务类原本没有实现某个接口,通过Aop的引介功能,也可以动态为该业务类添加接口的实现逻辑,让业务类成为这个接口的实现类
* **织入(Weaving)** 将增强添加到目标类的具体连接点的过程
* **代理(Proxy)** 一个类被aop织入增强后,就产生了一个结果类,他是融合了原类和增强逻辑的类,根据不通的代理方式,代理类可能是和原类具有相同接口的类,也可能就是原类的子类,也就是说可以采用与调用原类相同的方式调用代理类
* **切面(Aspect)** 切面由切点与增强(引介)组成,他即包含横切逻辑的定义,也包含连接点的定义.
####AOP织入方式
* 编译期织入,这要求特殊的java编译器
* 类装载期织入,这要求特殊的类装载器
* 动态代理织入,在运行期为目标类添加.增强.生成子类的方法
* Spring采用动态代理模式织入,而AspectJ采用编译期织入和类装载期织入
####ProxyFacotryBean
* **target** 代理的目标对象
* **proxyInterfaces** 代理所实现的接口,可以为多个
* **InterfacesNames** 需要织入目标对象的Bean列表,这些类必须实现MethodInterceptor或者Advisor的Bean,支持排序
* **singleton** 返回的代理对象是否为单例,默认是单例
* **optimize** 当设置为true时,强制使用CGLib动态代理,cglib创建对象速度慢,运行效率高,jdk代理创建对象速度快,运行效率慢
* **proxyTargetClass** 是否对类进行代理(而不是对接口进行代理),设置为true则使用CGLib代理,设置该属性后会忽略proxyInterfaces属性
####增强类型
* **MethodBeforeAdvice** 前置增强
* **AfterReturnAdvice** 后置增强,如果异常是方法内部声明的异常,则该异常归目标方法中,如果不是,则Spring将其转换为运行期异常抛出
* **MethodInterceptor** 环绕增强,采用AOP联盟定义实现接口
* **ThrowsAdvice** 异常抛出增强,空接口,在运行期Spring使用反射机制自行判断,必须采用以下签名形式定义异常抛出的增强方法
  * void afterThrowing([Method method,Object[] args,Object target],Throwable)
  * 注意前三个方法要么同时提供,要么同时不提供
  * 如果定义两个异常方法,异常类型不一样,Spring会优先选择相似度高的调用
* **IntroductionInterceptor** 引介增强,属于一种特殊的增强方式,他不是在目标类方法周围织入增强,而是为目标类创建新的方法和属性,所以引介增强是类级别的,通过引介增强,可以为目标类增加一个接口的实现,即原来的目标类未实现某个接口,通过引介增强为目标类创建实现某个接口的代理,Spring默认实现类型DelegatingIntroductionInterceptor,一般情况下都是扩展该类实现自己的增强类
####创建切面
* Spring通过PointCut接口来描述切点,该接口由ClassFilter与MethodMatcher,一个是定位特定类上,一个定位特定方法上
* Spring支持两种方法匹配器:静态方法匹配器和动态方法匹配器,静态匹配仅对方法签名(方法名和入参类型及顺序)进行匹配,动态匹配是在运行期检查方法的入参,每次调用方法可能入参都不一样所以每次都会判断,因此对性能有影响
####切点类型
* **静态方法切点** StaticMethodMatcherPointCut是静态方法切点的抽象基类,默认情况下他匹配所有的类,他包含两个子类NameMatchMethodPointCut和AbstractRegexpMethodPointcut前者提供简单的字符串匹配方法签名,后者使用正则表达式匹配方法签名
* **动态方法切点** DynamicMethodMatcherPointcut是动态方法切点的基类,默认情况下他匹配所有的类
* **注解切点** AnnotationMatchingPointcut实现类表示注解切点 使用AnnotationMatchingPointcut支持在bean中直接通过注解标签定义的切点
* **表达式切点** ExpressionPointcut为了支持AspectJ切点表达式语法定义的接口
* **流程切点** ControlFlowPointcut是一种特殊的切点,他根据程序执行堆栈的信息查看目标方法是否有某一个方法直接或间接发起调用,以此来判断是否为匹配的连接点
* **复合切点** ComposablePointcut 为创建多个切点而提供的方便操作类,他所有的方法都返回ComposablePointcut类,这样就可以使用链表表达式对切点进行操作
####切面类型
* **Advisor** 代表一般的切面 仅包含一个Advice,因为Advice包含横切代码和连接点的信息,所有Advice本身就是一个简单的切面
* **PointcutAdvisor** 代表具有切点的切面,包含Advice和Pointcut两个类,这样就可以通过类,方法名,方法方位等信息灵活的确认切面的连接点,六个实现类:
  * DefaultPointcutAdvisor: 最常用的切面类型,他可以通过任意Pointcut和Advice定义一个切面,不支持引介的切面类型,一般通过扩展该类实现自定义的切面
  * NameMatchMethodPointcutAdvisor: 通过该类可以定义按方法名定义切点的切面
  * RegexpMethodPointcutAdvisor: 正则表达式匹配方法进行切点定义的切面,可以通过扩展该类实现类进行操作,内部通过JdkRegexpMethodPointcut
  * StaticMethodMatcherPointcutAdvisor: 静态方法匹配器切点定义的切面 默认情况下匹配所有的目标类
  * AspectJExpressionPointcutAdvisor: 用于AspectJ切点表达式定义切点的切面
  * AspectJPointcutAdvisor: 用于AspectJ语法定义切点的切面
* **IntroductionAdvisor** 引介切面,他是对应引介增强的特殊的切面,他应用于类层面上,所以引介切点使用ClassFilter定义








