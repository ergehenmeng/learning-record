#### 主从复制的作用

* 做数据的热备
* 架构的扩张
* 读写分离

#### 主从复制的原理

* 从库连接主库,主库会创建一个线程发送`binlog`内容到从库
* 从库创建IO线程,该线程连接到主库并将主库发送过来的`binlog`的数据写入到本地文件 `repay log`
* 从库启动sql线程,从`repay log`读取数据并执行

#### 主从配置说明

```properties
## 主库配置
#设置服务器id,1表示主服务器
server-id = 1  
# 启动mysql的binlog日志
log_bin = /var/log/mysql/mysql-bin.log 
# 日志文件过期时间
expire_logs_days = 10 
# 日志文件最大大小
max_binlog_size = 100M 
# 同步数据的数据库名 多个并排写
binlog_do_db = project 
# 忽略要同步的数据库 
binlog_ignore_db = mysql 
```

#### SQL优化笔记

* **删除百万行数据**  先删除索引,再删除数据,最后重建索引 因为索修改的代价很大
* **truncate table** 如果没有外键关联,先`drop table`,再重建一个与原始表一样的空表,如果有外键则会变更为逐行删除

#### 内部缓存

> 服务器接收SQL,以 `SQL + DB + Query_cache_query_flags`最为hash查找缓存

* `show variables like %query_cache%` 查看与缓存有关的命令

| 变量名                       | 说明                     |
| ---------------------------- | ------------------------ |
| query_cache_min_res_unit     | 查询缓存分配块的最小尺寸 |
| query_cache_size             | 为缓存结果分配的内存大小 |
| query_cache_limit            | 不缓存大于该值的结果     |
| query_cache_type             | 是否缓存查询及结果集     |
| query_cache_wlock_invalidate |                          |

* `flush query cache` 清除查询缓存内存碎片
* `reset query cache` 从查询缓存中移出所有查询
* `flush tables` 关闭所有打开的表,该操作会清空查询缓存中的内容
* 在InnDB中,所有加锁操作的事务都不会使用任何查询缓存

#### 三范式

* **字段的原子性约束** 要求字段具有原子性,不可分割
* **记录的唯一性约束** 一张表只描述一件事情
* **字段的冗余性约束** ,任何字段都不能由其他字段派生出来

#### 优化

* 尽可能使用主键查询
* 条件查询尽可能不要使用 `!=` `<>`,因为会走全表扫描
* 尽量不要使用`select *` 
* 尽量用`join`查询代替子查询,因为子查询是嵌套查询,在进行嵌套查询时,会创建临时表,临时表的创建和销毁会耗费系统资源和花费一定时间
* 适当使用前缀索引 ,索引越长占用磁盘空间就越大,在相同数据页中存放的索引值也会越小,因此搜索索引需要的查询时间也就会越长,查询效率会变低
* 尽量使用小表驱动大表的方式进行查询 例如 A是大表 B是小表 `select * from A where id in (select id from B)`
* 尽量不要在查询条件上进行运算操作,因为索引会失效
* 适当增加冗余字段,减少不必要的多张表查询
* 尽可能最小的数据长度,例如使用`char` 而不是`varchar`
* 能使用`int`就不要使用`varchar`
* 适当使用分表(垂直,水平),分库策略
* 使用固态硬盘
* 使用多个小磁盘,而不是一个大磁盘
* 使用多个网卡
* 使用合适的存储引擎

## 表分区

#### 优势

* **存储更多的数据** 分区表的数据可以分布到不同的物理设备上,从而能高效的利用多个硬件设备
* **优化查询** where条件中包含分区条件时,可以只扫描一个或多个分区表来提供查询效率
* **分区表更容易维护** 例如删除大量数据时,可以直接清除整个分区
* **避免某些特殊的瓶颈** 例如InnDB的单个索引的互斥访问

#### 分区表限制

* 一个表只能有1024个分区
* 如果分区字段中有主键或者唯一索引的列,那么有主键或唯一索引的列都必须包含进去
* 分区表无法使用外键约束
* 分区适用于一个表的所有数据和索引,不能只对表数据进行分区不对索引分区,不能只对索引分区,不对数据分区,也不能只对部分数据分区

#### 分区类型

* **RANGE分区** 允许将数据划分不同的范围,例如将一个表通过年份分成若干的分区
* **LIST分区** 这种模式允许通过预定义的列表中的值来对数据进行分割,与range分区区别是 range分区时的区间范围值是连续的
* **HASH分区** 允许通过对表中一个或多个列进行Hash计算,最后通过hash码不同数值对应的数据区域进行区分,例如可以建立一个对表主键进行分区的表
* **KEY分区**  上面Hash模式的一种延伸,这里的Hash是由系统产生的





## 锁

#### 间隙锁

> 进行范围条件查询数据时,请求共享或排他锁时,InnoDB会给符合条件的已有数据记录的索引加锁,对键值在条件范围内,没有存在的记录叫**间隙(GAP)** ,InnoDB会对这个间隙加锁,简称间隙锁(Next_Key锁)

## binlog

#### 日志格式

* statement
* row 记录每一行数据的变动
* mixed