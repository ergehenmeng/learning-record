|     值     |                             说明                             |
| :--------: | :----------------------------------------------------------: |
|    read    | 作用于主内存变量,将一个变量值从主内存传输到线程的工作内存中,以便随后的load动作 |
|    load    | 作用于工作内存的变量,他将read操作从主内存中得到的变量值放入到工作内存的变量副本中 |
|    use     |   作用于工作内存的变量,把工作内存中的变量值传递给执行引擎    |
|   assign   | 作用于工作内存的变量,他把一个从执行引擎接收到的值赋值给工作内存的变量 |
|   store    | 作用于工作内存的变量,把工作内存的变量值传送给到主内存,以便于随后的write操作 |
|   write    | 作用于主内存的变量,他把store操作从工作内存中传递过来的变量保存到主内存变量中 |
|  **lock**  |     作用于主内存的变量,把一个变量标示为一个线程独占状态      |
| **unlock** | 作用于主内存变量,把一个处于锁定状态的变量释放,释放后才能被其他线程所持有 |

#### java内存模型规则

* 不允许`read`和`load`,`store`和`write`操作单独出现
* 不允许一个线程丢弃他最近`assign`操作,即变量在工作内存改变之后必须同步到主内存中
* 不允许一个线程无原因(没有发生过任何`assign`操作)的把数据从工作内存同步到主内存
* 一个新的变量只能在主内存中诞生,不允许在工作内存中直接使用一个未初始化(`load`或`assign`)的变量,即对一个变量进行`use`和`store`前,必须先执行`assign`和`load`操作
* 一个变量在同一个时刻只允许一个线程对其进行`lock`操作,`lock`与`unlock`必须成对出现
* 如果一个变量执行`lock`操作,将会清空工作内存中此变量的值,在执行引擎使用这个变量时,需要你重新执行`load`或者`assign`操作初始化变量的值
* 如果一个变量事项没有被`lock`操作锁定,则不允许对他执行`unlock`操作,也不允许`unlock`一个被其他线程锁定的变量
* 对一个变量执行`unlock`操作之前,必须先把该变量同步到主内存中(执行`store`和`write`操作)

#### volatile内存屏障

* volatile读之后,所以变量读写操作都不会重排序到前面
* volatile读之前,所有volatle读写操作都已完成
* volatile写之后,volatile变量读写操作都不会重排序到前面
* volatile写之前,所有变量的读写操作都已完成

* 在每一个volatile写操作前面插入一个`StoreStore`屏障,这确保了在进行volatile写之前所有的普通操作都已经刷新到内存
* 在每一个volatile写操作之后插入一个`StoreLoad`屏障,避免volatile写操作与后面可能存在的volatile读写操作发生重排
* 在每一个volatile读操作之前插入一个`LoadLoad`屏障,避免volatile读操作和后面的普通读操作进行重排
* 在每一个volatile读操作之后插入一个`LoadStore`屏障,避免volatile读操作和后面普通的写操作进行重排

#### java内存模型

* 内存模型: 为了保证共享内存的正确性,定义了在多线程下对共享内存读写操作规范
* java内存模式就是符合内存模型规范的,屏蔽了硬件和操作系统的访问差异性,保证java程序在各种平台下对内存访问都能达到一致效果的机制及规范

#### 类加载器

> 每个类加载器都有自己的命名空间,命名空间由该加载器及所有父加载器所加载的类组成